#!/usr/bin/env python

import os
import select
import sys


class SMTPStrangler:
    def __init__(self, logger, command_line_arguments):
        self.logger = logger
        self.command_line_arguments = command_line_arguments

        (self.from_client, self.to_client) = (sys.stdin.fileno(), sys.stdout.fileno())
        (self.from_proxy, self.to_server) = os.pipe()
        (self.from_server, self.to_proxy) = os.pipe()

        self.child_process_id = self.fork_and_prep(self.from_proxy, self.to_server, self.from_server, self.to_proxy)

    def strangle(self):
        if self.child_process_id:
            SMTPProxy(self.child_process_id, self.logger, self.from_client, self.to_server, self.from_server, self.to_client).proxy()
        else:
            SMTPProxied(self.command_line_arguments, self.logger, self.from_client, self.to_proxy, self.from_proxy, self.to_client).run()

    @staticmethod
    def fork_and_prep(from_proxy, to_server,
                      from_server, to_proxy):
        child = os.fork()
        if child:
            os.close(from_proxy)
            os.close(to_proxy)
        else:
            os.close(from_server)
            os.close(to_server)
        return child


class SMTPLogger:
    def __init__(self):
        self.fd = 2

    def logit(self, message):
        os.write(self.fd, message + b'\n')


class SMTPProxy:
    def __init__(self, child, logger, from_client, to_server, from_server, to_client):
        self.child = child
        self.logger = logger
        self.from_client = from_client
        self.to_server = to_server
        self.from_server = from_server
        self.to_client = to_client

        self.client_buffer = b''
        self.client_request = b''
        self.server_buffer = b''
        self.server_response = b''

    def proxy(self):
        self.read_and_process_until_either_end_closes()
        self.teardown_and_exit()

    @staticmethod
    def first_line_and_leftovers(possibly_multiline):
        (first_line, leftovers) = str.split(possibly_multiline, '\n', 1)
        first_line += '\n'
        return (first_line, leftovers)

    def log_client_request(self, some_bytes):
        self.client_buffer += some_bytes
        while '\n' in self.client_buffer:
            (line, leftovers) = self.first_line_and_leftovers(self.client_buffer)
            self.client_buffer = leftovers
            self.client_request += line
            if True:
                self.logger.logit(b'client< ' + self.client_request)
                self.client_request = b''

    @staticmethod
    def is_last_response_line(line):
        return len(line) >= 4 and ' ' == line[3]

    def log_server_response(self, some_bytes):
        self.server_buffer += some_bytes
        while '\n' in self.server_buffer:
            (line, leftovers) = self.first_line_and_leftovers(self.server_buffer)
            self.server_buffer = leftovers
            self.server_response += line
            if self.is_last_response_line(line):
                self.logger.logit(b'server> ' + self.server_response)
                self.server_response = b''

    def log_client_disconnect(self):
        self.log_client_request(b'[dropped connection]')

    def log_server_disconnect(self):
        self.log_server_response(b'[dropped connection]')

    @staticmethod
    def handle_some_bytes(from_fd, to_fd, log_bytes_fn, log_disconnect_fn):
        buffer_size = 77

        some_bytes = os.read(from_fd, buffer_size)
        if some_bytes:
            log_bytes_fn(some_bytes)
            os.write(to_fd, some_bytes)
            return True
        else:
            log_disconnect_fn()
            return False

    @staticmethod
    def readable_fds(of_these):
        (readable, writable, exceptional) = select.select(of_these, [], [])
        return readable

    def read_and_process_until_either_end_closes(self):
        handler_args_for = {
            self.from_client: (
                self.from_client,
                self.to_server,
                self.log_client_request,
                self.log_client_disconnect,
            ),
            self.from_server: (
                self.from_server,
                self.to_client,
                self.log_server_response,
                self.log_server_disconnect,
            ),
        }

        potentially_readable_fds = list(handler_args_for.keys())

        is_open = True
        while is_open:
            for fd in self.readable_fds(potentially_readable_fds):
                handler_args = handler_args_for[fd]
                if not self.handle_some_bytes(*handler_args):
                    is_open = False

    def teardown_and_exit(self):
        os.close(self.from_server)
        os.close(self.to_server)
        (pid, exitcode, resources) = os.wait4(self.child, 0)
        sys.exit(exitcode)


class SMTPProxied:
    def __init__(self, command_line_arguments, logger, from_client, to_proxy, from_proxy, to_client):
        self.command_line_arguments = command_line_arguments
        self.logger = logger

        os.dup2(from_proxy, from_client)
        os.dup2(to_proxy, to_client)

    def run(self):
        try:
            os.execvp(self.command_line_arguments[0], self.command_line_arguments)
        except OSError as o:
            self.logger.logit(o.strerror)


def die_usage(logger):
    this_program = os.path.basename(sys.argv[0]).encode('ASCII')
    logger.logit(b'usage: ' + this_program + b' prog [ arg ... ]')
    sys.exit(1)


def main(command_line_arguments):
    logger = SMTPLogger()
    if not command_line_arguments:
        die_usage(logger)
    SMTPStrangler(logger, command_line_arguments).strangle()


if '__main__' == __name__:
    main(sys.argv[1:])

# XXX
# 0. Log only entire requests and entire responses
# 1. Catch up to fixsmtpio_*.c
# 2. Check on 2.7 and 3.6
# 3. Test-drive from scratch (with both Pythons) for a git-crawl demo
