#!/usr/bin/env python

import os
import sys
import select

def logit(message):
    os.write(2, message + b'\n')
    pass

def die(message = b''):
    logit(message)
    sys.exit(1)

def die_usage():
    this_program = os.path.basename(sys.argv[0]).encode('ASCII')
    die(b'usage: ' + this_program + b' prog [ arg ... ]')

def log_client_bytes(message):
    logit(b'client< ' + message)

def log_client_disconnect():
    log_client_bytes(b'[dropped connection]')

def log_server_bytes(message):
    logit(b'server> ' + message)

def log_server_disconnect():
    log_server_bytes(b'[dropped connection]')

def handle_some_bytes(from_fd, to_fd, log_bytes_fn, log_disconnect_fn):
    buffer_size = 77

    some_bytes = os.read(from_fd, buffer_size)
    if some_bytes:
        log_bytes_fn(some_bytes)
        os.write(to_fd, some_bytes)
        return True
    else:
        log_disconnect_fn()
        return False

def readable_fds(of_these):
    (readable, writable, exceptional) = select.select(of_these, [], [])
    return readable

def read_and_process_until_either_end_closes(from_client, to_server,
                                             from_server, to_client):
    handler_args_for = {
        from_client: (
            from_client,
            to_server,
            log_client_bytes,
            log_client_disconnect,
        ),
        from_server: (
            from_server,
            to_client,
            log_server_bytes,
            log_server_disconnect,
        ),
    }

    potentially_readable_fds = list(handler_args_for.keys())

    is_open = True
    while is_open:
        for fd in readable_fds(potentially_readable_fds):
            handler_args = handler_args_for[fd]
            if not handle_some_bytes(*handler_args):
                is_open = False

def teardown_and_exit(child, from_server, to_server):
    os.close(from_server)
    os.close(to_server)
    (pid, exitcode, resources) = os.wait4(child, 0)
    sys.exit(exitcode)

def be_proxy(from_client, to_client,
             from_proxy,  to_proxy,
             from_server, to_server,
             child):
    os.close(from_proxy)
    os.close(to_proxy)
    read_and_process_until_either_end_closes(from_client, to_server,
                                             from_server, to_client)
    teardown_and_exit(child, from_server, to_server)

def be_proxied(from_proxy,  to_proxy,
               from_server, to_server,
               args):
    os.close(from_server)
    os.close(to_server)
    os.dup2(from_proxy, 0)
    os.dup2(to_proxy,   1)
    os.execvp(args[0], args)
    die

def main(args):
    if not args:
        die_usage()

    (from_client, to_client) = (0, 1)
    (from_proxy,  to_server) = os.pipe()
    (from_server, to_proxy)  = os.pipe()

    child = os.fork()
    if child:
        be_proxy(from_client, to_client,
                 from_proxy,  to_proxy,
                 from_server, to_server,
                 child)
    else:
        be_proxied(from_proxy,  to_proxy,
                   from_server, to_server,
                   args)


if '__main__' == __name__:
    main(sys.argv[1:])

# XXX
# 0. Log only entire requests and entire responses
# 1. Catch up to fixsmtpio_*.c
# 2. Check on 2.7 and 3.6
# 3. Test-drive from scratch (with both Pythons) for a git-crawl demo
