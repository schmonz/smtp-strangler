#!/usr/bin/env python

import os
import sys
import select

def logit(message, fd=2):
    os.write(fd, message + b'\n')
    pass

def die(message = b''):
    logit(message)
    sys.exit(1)

def die_usage():
    this_program = os.path.basename(sys.argv[0]).encode('ASCII')
    die(b'usage: ' + this_program + b' prog [ arg ... ]')

def log_client_bytes(message):
    logit(b'client< ' + message)

def log_server_bytes(message):
    logit(b'server> ' + message)

def read_and_process_until_either_end_closes(from_client, to_server,
                                             from_server, to_client):
    buffer_size = 77

    want_to_read = [from_client, from_server]

    someone_closed = 0
    while not someone_closed:
        (readable, writable, exceptional) = select.select(want_to_read, [], [])

        for fd in readable:
            if fd == from_client:
                more = os.read(from_client, buffer_size)
                if more:
                    log_client_bytes(more)
                    os.write(to_server, more)
                else:
                    someone_closed += 1
                    log_client_bytes(b'[dropped connection]')

            if fd == from_server:
                more = os.read(from_server, buffer_size)
                if more:
                    log_server_bytes(more)
                    os.write(to_client, more)
                else:
                    someone_closed += 1
                    log_server_bytes(b'[dropped connection]')

def teardown_and_exit(child, from_server, to_server):
    os.close(from_server)
    os.close(to_server)
    (pid, exitcode, resources) = os.wait4(child, 0)
    sys.exit(exitcode)

def be_proxy(from_client, to_client,
             from_proxy,  to_proxy,
             from_server, to_server,
             child):
    os.close(from_proxy)
    os.close(to_proxy)
    read_and_process_until_either_end_closes(from_client, to_server, from_server, to_client)
    teardown_and_exit(child, from_server, to_server)

def be_proxied(from_proxy,  to_proxy,
               from_server, to_server,
               args):
    os.close(from_server)
    os.close(to_server)
    os.dup2(from_proxy, 0)
    os.dup2(to_proxy, 1)
    os.execvp(args[0], args)
    die

def main(args):
    if (len(args) == 0):
        die_usage()

    (from_client, to_client) = (0, 1)
    (from_proxy, to_server) = os.pipe()
    (from_server, to_proxy) = os.pipe()

    child = os.fork()
    if child:
        be_proxy(from_client, to_client,
                 from_proxy,  to_proxy,
                 from_server, to_server,
                 child)
    else:
        be_proxied(from_proxy,  to_proxy,
                   from_server, to_server,
                   args)

if __name__ == '__main__':
    main(sys.argv[1:])

# XXX
# 1. Catch up to fixsmtpio_*.c
# 2. Check on 2.7 and 3.6
# 3. Test-drive from scratch (with both Pythons) for a git-crawl demo
