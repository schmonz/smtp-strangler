#!/usr/bin/env python

import os
import select
import sys


class ProtocolStrangler:
    def __init__(self, from_client, to_client):
        (self.from_client, self.to_client) = (from_client, to_client)
        (self.from_proxy, self.to_server) = os.pipe()
        (self.from_server, self.to_proxy) = os.pipe()
        self.child_process_id = os.fork()
        if self.child_process_id:
            os.close(self.from_proxy)
            os.close(self.to_proxy)
        else:
            os.close(self.from_server)
            os.close(self.to_server)

    def strangle_and_exit(self, logger, protocol, command_line_arguments):
        if self.child_process_id:
            if protocol == 'smtp':
                proxy = ProtocolProxy([
                    SMTPRequests(logger, self.from_client, self.to_server),
                    SMTPResponses(logger, self.from_server, self.to_client),
                ])
            else:
                proxy = ProtocolProxy([
                    GenericLinesIn(logger, self.from_client, self.to_server),
                    GenericLinesOut(logger, self.from_server, self.to_client),
                ])
            proxy.proxy_and_exit(self.child_process_id, 77)
        else:
            ProtocolProxied(
                self.from_client, self.to_proxy,
                self.from_proxy, self.to_client,
            ).exec_and_exit(logger, command_line_arguments)


class ProtocolLogger:
    def __init__(self, fd):
        self.__fd = fd

    def log(self, message):
        os.write(self.__fd, message)


class ProtocolBufferList:
    def __init__(self, buffer_list):
        self.__buffer_list = buffer_list
        self.__fd_list = []
        for each_buffer in self.__buffer_list:
            self.__fd_list.append(each_buffer.get_read_fd())

    def close(self):
        for each_buffer in self.__buffer_list:
            each_buffer.close()

    def get_readables(self):
        (reads, writes, exceptionals) = select.select(self.__fd_list, [], [])
        readables = []
        for each_buffer in self.__buffer_list:
            if each_buffer.get_read_fd() in reads:
                readables.append(each_buffer)
        return readables


class AbstractProtocolMessage:
    def __init__(self, logger, read_from_fd, write_to_fd):
        self.logger = logger
        self.__read_from_fd = read_from_fd
        self.__write_to_fd = write_to_fd

        self.__buffer = b''
        self.__protocol_message = b''
        self.safe_to_munge = True

    @staticmethod
    def __first_line_and_leftovers(possibly_multiline):
        (first_line, leftovers) = str.split(possibly_multiline, '\n', 1)
        first_line += '\n'
        return (first_line, leftovers)

    def __process_bytes(self, some_bytes):
        self.__buffer += some_bytes
        while '\n' in self.__buffer:
            (line, leftovers) = self.__first_line_and_leftovers(self.__buffer)
            self.__buffer = leftovers
            self.__protocol_message += line
            if self.is_last_line_of_protocol_message(line):
                self.logger.log(b'       ' + self.get_log_prefix() +
                                b' ' + self.__protocol_message)
                munged_message = self.munge_message(self.__protocol_message)
                self.logger.log(b'munged-' + self.get_log_prefix() +
                                b' ' + munged_message + '\n')
                os.write(self.__write_to_fd, munged_message)
                self.__protocol_message = b''

    def get_read_fd(self):
        return self.__read_from_fd

    def get_write_fd(self):
        return self.__write_to_fd

    def go(self, read_length):
        some_bytes = os.read(self.__read_from_fd, read_length)
        if some_bytes:
            self.__process_bytes(some_bytes)
            return True
        else:
            self.log_disconnect()
            return False


class GenericLinesIn(AbstractProtocolMessage):
    def close(self):
        os.close(self.get_write_fd())

    def is_last_line_of_protocol_message(self, line):
        return True

    @staticmethod
    def get_log_prefix():
        return b'unspecified-request>'

    def log_disconnect(self):
        self.logger.log(b'[client dropped connection]\n')

    def munge_message(self, message):
        return message


class GenericLinesOut(AbstractProtocolMessage):
    def close(self):
        os.close(self.get_read_fd())

    def is_last_line_of_protocol_message(self, line):
        return True

    @staticmethod
    def get_log_prefix():
        return b'unspecified-response>'

    def log_disconnect(self):
        self.logger.log(b'[server dropped connection]\n')

    def munge_message(self, message):
        return message


class SMTPRequests(AbstractProtocolMessage):
    def close(self):
        os.close(self.get_write_fd())

    def is_last_line_of_protocol_message(self, line):
        # XXX case-insensitive, and verb only, and server agrees
        if self.safe_to_munge and line == 'data\n':
            # XXX self.want_data = True
            self.safe_to_munge = False
        if not self.safe_to_munge and line == '.\n':
            self.safe_to_munge = True
        return True

    @staticmethod
    def get_log_prefix():
        return b'request>'

    def log_disconnect(self):
        self.logger.log(b'[client dropped connection]\n')

    def munge_message(self, message):
        if not self.safe_to_munge:
            return message

        munged_message = message.rstrip('\r\n')
        # XXX case-insensitive, and verb only
        if munged_message.startswith('word '):
            munged_message = 'noop ' + munged_message
        munged_message += '\r\n'
        return munged_message


class SMTPResponses(AbstractProtocolMessage):
    def close(self):
        os.close(self.get_read_fd())

    def is_last_line_of_protocol_message(self, line):
        return len(line) >= 4 and ' ' == line[3]

    @staticmethod
    def get_log_prefix():
        return b'response<'

    def log_disconnect(self):
        self.logger.log(b'[server dropped connection]\n')

    def munge_message(self, message):
        if not self.safe_to_munge:
            return message

        return message


class ProtocolProxy:
    def __init__(self, buffers):
        self.__buffers = ProtocolBufferList(buffers)

    @staticmethod
    def __await_child_exitcode(child):
        (pid, exitcode, resources) = os.wait4(child, 0)
        return exitcode

    def proxy_and_exit(self, child, read_length):
        someone_closed = False
        while not someone_closed:
            for readable in self.__buffers.get_readables():
                if not readable.go(read_length):
                    someone_closed = True

        self.__buffers.close()
        sys.exit(self.__await_child_exitcode(child))


class ProtocolProxied:
    def __init__(self, from_client, to_proxy, from_proxy, to_client):
        os.dup2(from_proxy, from_client)
        os.dup2(to_proxy, to_client)

    def exec_and_exit(self, logger, command_line_arguments):
        program_to_strangle = command_line_arguments[0]
        try:
            os.execvp(program_to_strangle, command_line_arguments)
        except OSError as o:
            logger.log(program_to_strangle + ': ' + o.strerror + '\n')


def die_usage(logger):
    this_program = os.path.basename(sys.argv[0]).encode('ASCII')
    logger.log(b'usage: ' + this_program +
               b' program-to-strangle [ arg ... ]\n')
    sys.exit(99)


def main(command_line_arguments):
    logger = ProtocolLogger(sys.stderr.fileno())
    if not command_line_arguments:
        die_usage(logger)
    ProtocolStrangler(
        sys.stdin.fileno(),
        sys.stdout.fileno(),
    ).strangle_and_exit(logger, 'smtp', command_line_arguments)


if '__main__' == __name__:
    main(sys.argv[1:])
