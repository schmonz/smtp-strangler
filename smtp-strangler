#!/usr/bin/env python

import os
import select
import sys


class ProtocolStrangler:
    def __init__(self, logger, command_line_arguments):
        self.logger = logger
        self.command_line_arguments = command_line_arguments

        (self.from_client, self.to_client) = (sys.stdin.fileno(), sys.stdout.fileno())
        (self.from_proxy, self.to_server) = os.pipe()
        (self.from_server, self.to_proxy) = os.pipe()

        self.child_process_id = self.fork_and_prep(self.from_proxy, self.to_server, self.from_server, self.to_proxy)

    def strangle(self):
        if self.child_process_id:
            request_buffer = SMTPRequestBuffer(self.logger, self.from_client, self.to_server)
            response_buffer = SMTPResponseBuffer(self.logger, self.from_server, self.to_client)
            ProtocolProxy(self.child_process_id, request_buffer, response_buffer).proxy()
        else:
            ProtocolProxied(self.command_line_arguments, self.logger, self.from_client, self.to_proxy, self.from_proxy, self.to_client).run()

    @staticmethod
    def fork_and_prep(from_proxy, to_server,
                      from_server, to_proxy):
        child = os.fork()
        if child:
            os.close(from_proxy)
            os.close(to_proxy)
        else:
            os.close(from_server)
            os.close(to_server)
        return child


class ProtocolLogger:
    def __init__(self):
        self.fd = 2

    def logit(self, message):
        os.write(self.fd, message + b'\n')


class AbstractProtocolMessage:
    def __init__(self, logger, read_from_fd, write_to_fd):
        self.logger = logger
        self.read_from_fd = read_from_fd
        self.write_to_fd = write_to_fd

        self.buffer = b''
        self.protocol_message = b''

    @staticmethod
    def first_line_and_leftovers(possibly_multiline):
        (first_line, leftovers) = str.split(possibly_multiline, '\n', 1)
        first_line += '\n'
        return (first_line, leftovers)

    def process_bytes(self, some_bytes):
        self.buffer += some_bytes
        while '\n' in self.buffer:
            (line, leftovers) = self.first_line_and_leftovers(self.buffer)
            self.buffer = leftovers
            self.protocol_message += line
            if self.is_last_line_of_protocol_message(line):
                self.logger.logit(self.get_log_prefix() + b' ' + self.protocol_message)
                self.protocol_message = b''

    def proxy_more_stuff(self):
        buffer_size = 77

        some_bytes = os.read(self.read_from_fd, buffer_size)
        if some_bytes:
            self.process_bytes(some_bytes)
            os.write(self.write_to_fd, some_bytes)
            return True
        else:
            self.log_disconnect()
            return False


class SMTPRequestBuffer(AbstractProtocolMessage):
    @staticmethod
    def is_last_line_of_protocol_message(line):
        return True

    @staticmethod
    def get_log_prefix():
        return b'request>'

    def log_disconnect(self):
        self.logger.logit(b'[client dropped connection]')


class SMTPResponseBuffer(AbstractProtocolMessage):
    @staticmethod
    def is_last_line_of_protocol_message(line):
        return len(line) >= 4 and ' ' == line[3]

    @staticmethod
    def get_log_prefix():
        return b'response<'

    def log_disconnect(self):
        self.logger.logit(b'[server dropped connection]')


class ProtocolProxy:
    def __init__(self, child, request_buffer, response_buffer):
        self.child = child
        self.request_buffer = request_buffer
        self.response_buffer = response_buffer

    def proxy(self):
        is_open = True
        while is_open:
            for message_buffer in self.readable_buffers(self.request_buffer, self.response_buffer):
                if not message_buffer.proxy_more_stuff():
                    is_open = False

        os.close(self.response_buffer.read_from_fd)
        os.close(self.request_buffer.write_to_fd)
        (pid, exitcode, resources) = os.wait4(self.child, 0)
        sys.exit(exitcode)

    @staticmethod
    def readable_buffers(one, two):
        readables = []
        of_these = (one.read_from_fd, two.read_from_fd)
        (readable_fds, writable_fds, exceptional_fds) = select.select(of_these, [], [])
        if one.read_from_fd in readable_fds:
            readables.append(one)
        if two.read_from_fd in readable_fds:
            readables.append(two)
        return readables


class ProtocolProxied:
    def __init__(self, command_line_arguments, logger, from_client, to_proxy, from_proxy, to_client):
        self.command_line_arguments = command_line_arguments
        self.logger = logger

        os.dup2(from_proxy, from_client)
        os.dup2(to_proxy, to_client)

    def run(self):
        try:
            os.execvp(self.command_line_arguments[0], self.command_line_arguments)
        except OSError as o:
            self.logger.logit(o.strerror)


def die_usage(logger):
    this_program = os.path.basename(sys.argv[0]).encode('ASCII')
    logger.logit(b'usage: ' + this_program + b' prog [ arg ... ]')
    sys.exit(1)


def main(command_line_arguments):
    logger = ProtocolLogger()
    if not command_line_arguments:
        die_usage(logger)
    ProtocolStrangler(logger, command_line_arguments).strangle()


if '__main__' == __name__:
    main(sys.argv[1:])

# XXX
# 0. Log only entire requests and entire responses
# 1. Catch up to fixsmtpio_*.c
# 2. Check on 2.7 and 3.6
# 3. Test-drive from scratch (with both Pythons) for a git-crawl demo
