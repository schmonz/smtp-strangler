#!/usr/bin/env python

import os
import select
import sys


def logit(message):
    os.write(2, message + b'\n')
    pass


def die(message=b''):
    logit(message)
    sys.exit(1)


def die_usage():
    this_program = os.path.basename(sys.argv[0]).encode('ASCII')
    die(b'usage: ' + this_program + b' prog [ arg ... ]')


def log_client_bytes(message):
    logit(b'client< ' + message)


def log_client_disconnect():
    log_client_bytes(b'[dropped connection]')


def log_server_bytes(message):
    logit(b'server> ' + message)


def log_server_disconnect():
    log_server_bytes(b'[dropped connection]')


def fork_and_prep(from_proxy, to_server,
                  from_server, to_proxy):
    child = os.fork()
    if child:
        os.close(from_proxy)
        os.close(to_proxy)
    else:
        os.close(from_server)
        os.close(to_server)
    return child


class SMTPProxy:
    def __init__(self, child, from_client, to_server, from_server, to_client):
        self.child = child
        self.from_client = from_client
        self.to_server = to_server
        self.from_server = from_server
        self.to_client = to_client

        self.read_and_process_until_either_end_closes()
        self.teardown_and_exit()

    @staticmethod
    def handle_some_bytes(from_fd, to_fd, log_bytes_fn, log_disconnect_fn):
        buffer_size = 77

        some_bytes = os.read(from_fd, buffer_size)
        if some_bytes:
            log_bytes_fn(some_bytes)
            os.write(to_fd, some_bytes)
            return True
        else:
            log_disconnect_fn()
            return False

    @staticmethod
    def readable_fds(of_these):
        (readable, writable, exceptional) = select.select(of_these, [], [])
        return readable

    def read_and_process_until_either_end_closes(self):
        handler_args_for = {
            self.from_client: (
                self.from_client,
                self.to_server,
                log_client_bytes,
                log_client_disconnect,
            ),
            self.from_server: (
                self.from_server,
                self.to_client,
                log_server_bytes,
                log_server_disconnect,
            ),
        }

        potentially_readable_fds = list(handler_args_for.keys())

        is_open = True
        while is_open:
            for fd in self.readable_fds(potentially_readable_fds):
                handler_args = handler_args_for[fd]
                if not self.handle_some_bytes(*handler_args):
                    is_open = False

    def teardown_and_exit(self):
        os.close(self.from_server)
        os.close(self.to_server)
        (pid, exitcode, resources) = os.wait4(self.child, 0)
        sys.exit(exitcode)


class SMTPProxied:
    def __init__(self, args, from_client, to_proxy, from_proxy, to_client):
        os.dup2(from_proxy, from_client)
        os.dup2(to_proxy, to_client)
        os.execvp(args[0], args)


class SMTPStrangler:
    def __init__(self, args):
        if not args:
            die_usage()

        (from_client, to_client) = (0, 1)
        (from_proxy, to_server) = os.pipe()
        (from_server, to_proxy) = os.pipe()

        child = fork_and_prep(from_proxy, to_server, from_server, to_proxy)
        if child:
            SMTPProxy(child, from_client, to_server, from_server, to_client)
        else:
            SMTPProxied(args, from_client, to_proxy, from_proxy, to_client)


def main(args):
    SMTPStrangler(args)


if '__main__' == __name__:
    main(sys.argv[1:])

# XXX
# 0. Log only entire requests and entire responses
# 1. Catch up to fixsmtpio_*.c
# 2. Check on 2.7 and 3.6
# 3. Test-drive from scratch (with both Pythons) for a git-crawl demo
