#!/usr/bin/env python

import os
import select
import sys


class ProtocolStrangler:
    def __init__(self, from_client, to_client):
        (self.from_client, self.to_client) = (from_client, to_client)
        (self.from_proxy, self.to_server) = os.pipe()
        (self.from_server, self.to_proxy) = os.pipe()
        self.child_process_id = self.__fork_and_prep(self.from_proxy, self.to_server, self.from_server, self.to_proxy)

    def go(self, logger, command_line_arguments):
        if self.child_process_id:
            request_buffer = SMTPRequestBuffer(logger, self.from_client, self.to_server)
            response_buffer = SMTPResponseBuffer(logger, self.from_server, self.to_client)
            proxy = ProtocolProxy(request_buffer, response_buffer)
            proxy.go(self.child_process_id, 77)
        else:
            proxied = ProtocolProxied(self.from_client, self.to_proxy, self.from_proxy, self.to_client)
            proxied.go(logger, command_line_arguments)

    @staticmethod
    def __fork_and_prep(from_proxy, to_server,
                        from_server, to_proxy):
        child = os.fork()
        if child:
            os.close(from_proxy)
            os.close(to_proxy)
        else:
            os.close(from_server)
            os.close(to_server)
        return child


class ProtocolLogger:
    def __init__(self, fd):
        self.__fd = fd

    def logit(self, message):
        os.write(self.__fd, message + b'\n')


class ProtocolBuffers:
    def __init__(self, list_of_buffers):
        self.__list_of_buffers = list_of_buffers
        self.__list_of_fds = []
        for each_buffer in self.__list_of_buffers:
            self.__list_of_fds.append(each_buffer.get_read_fd())

    def close(self):
        for each_buffer in self.__list_of_buffers:
            each_buffer.close()

    def get_readables(self):
        (readable_fds, writable_fds, exceptional_fds) = select.select(self.__list_of_fds, [], [])
        readables = []
        for each_buffer in self.__list_of_buffers:
            if each_buffer.get_read_fd() in readable_fds:
                readables.append(each_buffer)
        return readables


class AbstractProtocolMessage:
    def __init__(self, logger, read_from_fd, write_to_fd):
        self.logger = logger
        self.__read_from_fd = read_from_fd
        self.__write_to_fd = write_to_fd

        self.__buffer = b''
        self.__protocol_message = b''

    @staticmethod
    def __first_line_and_leftovers(possibly_multiline):
        (first_line, leftovers) = str.split(possibly_multiline, '\n', 1)
        first_line += '\n'
        return (first_line, leftovers)

    def __process_bytes(self, some_bytes):
        self.__buffer += some_bytes
        while '\n' in self.__buffer:
            (line, leftovers) = self.__first_line_and_leftovers(self.__buffer)
            self.__buffer = leftovers
            self.__protocol_message += line
            if self.is_last_line_of_protocol_message(line):
                self.logger.logit(self.get_log_prefix() + b' ' + self.__protocol_message)
                self.__protocol_message = b''

    def get_read_fd(self):
        return self.__read_from_fd

    def get_write_fd(self):
        return self.__write_to_fd

    def go(self, read_length):
        some_bytes = os.read(self.__read_from_fd, read_length)
        if some_bytes:
            self.__process_bytes(some_bytes)
            os.write(self.__write_to_fd, some_bytes)
            return True
        else:
            self.log_disconnect()
            return False


class SMTPRequestBuffer(AbstractProtocolMessage):
    def close(self):
        os.close(self.get_write_fd())

    @staticmethod
    def is_last_line_of_protocol_message(line):
        return True

    @staticmethod
    def get_log_prefix():
        return b'request>'

    def log_disconnect(self):
        self.logger.logit(b'[client dropped connection]')


class SMTPResponseBuffer(AbstractProtocolMessage):
    def close(self):
        os.close(self.get_read_fd())

    @staticmethod
    def is_last_line_of_protocol_message(line):
        return len(line) >= 4 and ' ' == line[3]

    @staticmethod
    def get_log_prefix():
        return b'response<'

    def log_disconnect(self):
        self.logger.logit(b'[server dropped connection]')


class ProtocolProxy:
    def __init__(self, request_buffer, response_buffer):
        self.__buffers = ProtocolBuffers([request_buffer, response_buffer])

    @staticmethod
    def __await_child_exitcode(child):
        (pid, exitcode, resources) = os.wait4(child, 0)
        return exitcode

    def go(self, child, read_length):
        is_open = True
        while is_open:
            for readable in self.__buffers.get_readables():
                if not readable.go(read_length):
                    is_open = False

        self.__buffers.close()
        sys.exit(self.__await_child_exitcode(child))


class ProtocolProxied:
    def __init__(self, from_client, to_proxy, from_proxy, to_client):
        os.dup2(from_proxy, from_client)
        os.dup2(to_proxy, to_client)

    def go(self, logger, command_line_arguments):
        try:
            os.execvp(command_line_arguments[0], command_line_arguments)
        except OSError as o:
            logger.logit(o.strerror)


def die_usage(logger):
    this_program = os.path.basename(sys.argv[0]).encode('ASCII')
    logger.logit(b'usage: ' + this_program + b' program-to-strangle [ arg ... ]')
    sys.exit(99)


def main(command_line_arguments):
    logger = ProtocolLogger(sys.stderr.fileno())
    if not command_line_arguments:
        die_usage(logger)
    strangler = ProtocolStrangler(sys.stdin.fileno(), sys.stdout.fileno())
    strangler.go(logger, command_line_arguments)


if '__main__' == __name__:
    main(sys.argv[1:])
